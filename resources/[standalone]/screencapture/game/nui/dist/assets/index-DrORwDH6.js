var T=t=>{throw TypeError(t)};var R=(t,e,r)=>e.has(t)||T("Cannot "+r);var s=(t,e,r)=>(R(t,e,"read from private field"),r?r.call(t):e.get(t)),f=(t,e,r)=>e.has(t)?T("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),d=(t,e,r,i)=>(R(t,e,"write to private field"),i?i.call(t,r):e.set(t,r),r);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))i(a);new MutationObserver(a=>{for(const o of a)if(o.type==="childList")for(const n of o.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function r(a){const o={};return a.integrity&&(o.integrity=a.integrity),a.referrerPolicy&&(o.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?o.credentials="include":a.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(a){if(a.ep)return;a.ep=!0;const o=r(a);fetch(a.href,o)}})();var A=`
  attribute vec2 a_position;
  attribute vec2 a_texcoord;
  uniform mat3 u_matrix;
  varying vec2 textureCoordinate;
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    textureCoordinate = a_texcoord;
  }
`,p=`
varying highp vec2 textureCoordinate;
uniform sampler2D external_texture;
void main()
{
  gl_FragColor = texture2D(external_texture, textureCoordinate);
}
`;function m(t,e,r){let i=t.createShader(e);if(!i)throw new Error("Failed to create shader");t.shaderSource(i,r),t.compileShader(i);let a=t.getShaderInfoLog(i);return a&&console.error(a),i}function g(t){let e=t.createTexture(),r=new Uint8Array([0,0,255,255]);return t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,r),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.MIRRORED_REPEAT),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),e}function v(t){let e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),t.STATIC_DRAW);let r=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),t.STATIC_DRAW),{vertexBuff:e,texBuff:r}}function w(t){let e=m(t,t.VERTEX_SHADER,A),r=m(t,t.FRAGMENT_SHADER,p),i=t.createProgram();if(!i)throw new Error("Failed to create program");t.attachShader(i,e),t.attachShader(i,r),t.linkProgram(i),t.useProgram(i);let a=t.getAttribLocation(i,"a_position"),o=t.getAttribLocation(i,"a_texcoord");return{program:i,vloc:a,tloc:o}}function x(t){let e=t.getContext("webgl",{antialias:!1,depth:!1,stencil:!1,alpha:!1,desynchronized:!0,failIfMajorPerformanceCaveat:!1}),r=()=>{};function i(){let o=g(e),{program:n,vloc:u,tloc:E}=w(e),{vertexBuff:h,texBuff:_}=v(e);e.useProgram(n),e.bindTexture(e.TEXTURE_2D,o),e.uniform1i(e.getUniformLocation(n,"external_texture"),0),e.bindBuffer(e.ARRAY_BUFFER,h),e.vertexAttribPointer(u,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(u),e.bindBuffer(e.ARRAY_BUFFER,_),e.vertexAttribPointer(E,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(E),e.viewport(0,0,e.canvas.width,e.canvas.height),r()}let a={canvas:t,gl:e,animationFrame:void 0,resize:(o,n)=>{e.viewport(0,0,o,n),e.canvas.width=o,e.canvas.height=n}};return r=()=>{e.drawArrays(e.TRIANGLE_STRIP,0,4),e.finish(),a.animationFrame=requestAnimationFrame(r)},i(),a}var l,c;class P{constructor(){f(this,l);f(this,c,null)}start(){window.addEventListener("message",async e=>{const r=e.data;r.action==="capture"&&await this.captureScreen(r)}),window.addEventListener("resize",()=>{s(this,l)&&s(this,l).resize(window.innerWidth,window.innerHeight)})}async captureScreen(e){d(this,c,document.createElement("canvas")),s(this,c).width=window.innerWidth,s(this,c).height=window.innerHeight,d(this,l,x(s(this,c)));const r=e.encoding??"png",i=e.quality??.5;let a;if(e.serverEndpoint||!e.formField?a=await this.createBlob(s(this,c),r,i):a=await this.createBlob(s(this,c),r,i),!a)return console.error("No image available");await this.httpUploadImage(e,a),s(this,c).remove()}async httpUploadImage(e,r){const i=this.createRequestBody(e,r);if(e.serverEndpoint)try{await fetch(e.serverEndpoint,{method:"POST",headers:{"X-ScreenCapture-Token":e.uploadToken},body:i})}catch(a){console.error(a)}}createRequestBody(e,r){if(r instanceof Blob){const i=new FormData;return i.append(e.formField??"file",r),i}return JSON.stringify({imageData:r,dataType:e.dataType})}createDataURL(e){return new Promise((r,i)=>{const a=e.toDataURL("image/webp",.7);a||i("No data URL available"),r(a)})}createBlob(e,r,i=.7){return new Promise((a,o)=>{e.toBlob(n=>{n?a(n):o("No blob available")},`image/${r}`,i)})}}l=new WeakMap,c=new WeakMap;const b=new P;b.start();
